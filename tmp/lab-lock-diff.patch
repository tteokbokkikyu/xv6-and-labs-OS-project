diff --git a/kernel/bio.c b/kernel/bio.c
index 60d91a6..a58a3cc 100644
--- a/kernel/bio.c
+++ b/kernel/bio.c
@@ -23,32 +23,39 @@
 #include "fs.h"
 #include "buf.h"
 
+#define HASH(blockno) (blockno % NBUCKET)
+extern uint ticks;
+
 struct {
   struct spinlock lock;
   struct buf buf[NBUF];
+  // 记录已经分配到哈希表的缓存块 struct buf 的数量
+  int size;
+  // 哈希表的 bucket 数组
+  struct buf buckets[NBUCKET];
+  // 作为每个 bucket 对应的锁
+  struct spinlock locks[NBUCKET];
+  // 哈希表的全局锁, 用于对哈希表整体加锁
+  struct spinlock hashlock;
 
-  // Linked list of all buffers, through prev/next.
-  // Sorted by how recently the buffer was used.
-  // head.next is most recent, head.prev is least.
-  struct buf head;
 } bcache;
 
 void
 binit(void)
 {
+  int i;
   struct buf *b;
 
+  bcache.size = 0;
   initlock(&bcache.lock, "bcache");
+  // 初始化哈希锁
+  initlock(&bcache.hashlock, "bcache_hash");
+  for(i = 0; i < NBUCKET; ++i) {
+    initlock(&bcache.locks[i], "bcache_bucket");
+  }
 
-  // Create linked list of buffers
-  bcache.head.prev = &bcache.head;
-  bcache.head.next = &bcache.head;
   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
     initsleeplock(&b->lock, "buffer");
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
   }
 }
 
@@ -59,31 +66,85 @@ static struct buf*
 bget(uint dev, uint blockno)
 {
   struct buf *b;
-
-  acquire(&bcache.lock);
-
-  // Is the block already cached?
-  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+  // 定义一些变量
+  int idx = HASH(blockno);
+  struct buf *pre, *minb = 0, *minpre;
+  uint mintimestamp;
+  int i;
+
+  // 在buckets[idx]里循环buf
+  acquire(&bcache.locks[idx]);
+  for(b = bcache.buckets[idx].next; b; b = b->next){
     if(b->dev == dev && b->blockno == blockno){
       b->refcnt++;
-      release(&bcache.lock);
+      release(&bcache.locks[idx]);
       acquiresleep(&b->lock);
       return b;
     }
   }
 
-  // Not cached.
-  // Recycle the least recently used (LRU) unused buffer.
-  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
-    if(b->refcnt == 0) {
-      b->dev = dev;
-      b->blockno = blockno;
-      b->valid = 0;
-      b->refcnt = 1;
-      release(&bcache.lock);
-      acquiresleep(&b->lock);
-      return b;
-    }
+  
+  acquire(&bcache.lock);
+  if(bcache.size < NBUF) {
+    b = &bcache.buf[bcache.size++];
+    release(&bcache.lock);
+    b->dev = dev;
+    b->blockno = blockno;
+    b->valid = 0;
+    b->refcnt = 1;
+    b->next = bcache.buckets[idx].next;
+    bcache.buckets[idx].next = b;
+    release(&bcache.locks[idx]);
+    acquiresleep(&b->lock);
+    return b;
+  }
+  release(&bcache.lock);
+  release(&bcache.locks[idx]);
+
+  
+  acquire(&bcache.hashlock);
+  for(i = 0; i < NBUCKET; ++i) {
+      mintimestamp = -1;
+      acquire(&bcache.locks[idx]);
+      for(pre = &bcache.buckets[idx], b = pre->next; b; pre = b, b = b->next) {
+          // research the block
+          if(idx == HASH(blockno) && b->dev == dev && b->blockno == blockno){
+              b->refcnt++;
+              release(&bcache.locks[idx]);
+              release(&bcache.hashlock);
+              acquiresleep(&b->lock);
+              return b;
+          }
+          if(b->refcnt == 0 && b->timestamp < mintimestamp) {
+              minb = b;
+              minpre = pre;
+              mintimestamp = b->timestamp;
+          }
+      }
+      // find an unused block
+      if(minb) {
+          minb->dev = dev;
+          minb->blockno = blockno;
+          minb->valid = 0;
+          minb->refcnt = 1;
+          // if block in another bucket, we should move it to correct bucket
+          if(idx != HASH(blockno)) {
+              minpre->next = minb->next;    // remove block
+              release(&bcache.locks[idx]);
+              idx = HASH(blockno);  // the correct bucket index
+              acquire(&bcache.locks[idx]);
+              minb->next = bcache.buckets[idx].next;    // move block to correct bucket
+              bcache.buckets[idx].next = minb;
+          }
+          release(&bcache.locks[idx]);
+          release(&bcache.hashlock);
+          acquiresleep(&minb->lock);
+          return minb;
+      }
+      release(&bcache.locks[idx]);
+      if(++idx == NBUCKET) {
+          idx = 0;
+      }
   }
   panic("bget: no buffers");
 }
@@ -116,38 +177,40 @@ bwrite(struct buf *b)
 void
 brelse(struct buf *b)
 {
+   int idx;
   if(!holdingsleep(&b->lock))
     panic("brelse");
 
   releasesleep(&b->lock);
 
-  acquire(&bcache.lock);
+   // 改变锁
+  idx = HASH(b->blockno);
+  acquire(&bcache.locks[idx]);
   b->refcnt--;
   if (b->refcnt == 0) {
-    // no one is waiting for it.
-    b->next->prev = b->prev;
-    b->prev->next = b->next;
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
+    // 改变时间戳记录的缓存块
+    b->timestamp = ticks;
   }
   
-  release(&bcache.lock);
+   release(&bcache.locks[idx]);
 }
 
 void
 bpin(struct buf *b) {
-  acquire(&bcache.lock);
+   // 改变锁，将原本的全局锁替换为缓存块对应的 bucket 的锁
+  int idx = HASH(b->blockno);
+  acquire(&bcache.locks[idx]);
   b->refcnt++;
-  release(&bcache.lock);
+  release(&bcache.locks[idx]);
 }
 
 void
 bunpin(struct buf *b) {
-  acquire(&bcache.lock);
+   // 改变锁，将原本的全局锁替换为缓存块对应的 bucket 的锁
+  int idx = HASH(b->blockno);
+  acquire(&bcache.locks[idx]);
   b->refcnt--;
-  release(&bcache.lock);
+  release(&bcache.locks[idx]);
 }
 
 
diff --git a/kernel/buf.h b/kernel/buf.h
index 4616e9e..d2d525a 100644
--- a/kernel/buf.h
+++ b/kernel/buf.h
@@ -5,8 +5,10 @@ struct buf {
   uint blockno;
   struct sleeplock lock;
   uint refcnt;
-  struct buf *prev; // LRU cache list
+  //struct buf *prev; // LRU cache list
   struct buf *next;
   uchar data[BSIZE];
+   // 记录最后使用缓存块的时间
+  uint timestamp;
 };
 
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index fa6a0ac..93a2d6f 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -18,15 +18,24 @@ struct run {
   struct run *next;
 };
 
+
+// 给每个CPU都设置一个这个结构体
 struct {
   struct spinlock lock;
   struct run *freelist;
-} kmem;
+  // 保存锁的名字
+  char lockname[8];
+} kmems[NCPU];
 
+// 初始化kmems数组
 void
 kinit()
 {
-  initlock(&kmem.lock, "kmem");
+  int i;
+  for (i = 0; i < NCPU; ++i) {
+    snprintf(kmems[i].lockname, 8, "kmem_%d", i);
+    initlock(&kmems[i].lock, kmems[i].lockname);
+  }
   freerange(end, (void*)PHYSTOP);
 }
 
@@ -47,7 +56,9 @@ void
 kfree(void *pa)
 {
   struct run *r;
-
+  // 变量记录CPUid
+  int c;
+  
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
     panic("kfree");
 
@@ -56,12 +67,46 @@ kfree(void *pa)
 
   r = (struct run*)pa;
 
-  acquire(&kmem.lock);
-  r->next = kmem.freelist;
-  kmem.freelist = r;
-  release(&kmem.lock);
+   // 获取当前的cpuid
+  push_off();
+  c = cpuid();
+  pop_off();
+  // 用于回收物理页到当前cpu的freelist
+  acquire(&kmems[c].lock);
+  r->next = kmems[c].freelist;
+  kmems[c].freelist = r;
+  release(&kmems[c].lock);
 }
 
+struct run *steal(int cpu_id) {
+    int i;
+    int c = cpu_id;
+    struct run *fast, *slow, *head;
+    // 首先找到哪个cpu有空闲，之后偷取
+    for (i = 1; i < NCPU; ++i) {
+        if (++c == NCPU) {
+            c = 0;
+        }
+        acquire(&kmems[c].lock);
+        if (kmems[c].freelist) {
+            slow = head = kmems[c].freelist;
+            fast = slow->next;
+            while (fast) {
+                fast = fast->next;
+                if (fast) {
+                    slow = slow->next;
+                    fast = fast->next;
+                }
+            }
+            kmems[c].freelist = slow->next;
+            release(&kmems[c].lock);
+            slow->next = 0;
+            return head;
+        }
+        release(&kmems[c].lock);
+    }
+    return 0;
+}
 // Allocate one 4096-byte page of physical memory.
 // Returns a pointer that the kernel can use.
 // Returns 0 if the memory cannot be allocated.
@@ -69,12 +114,22 @@ void *
 kalloc(void)
 {
   struct run *r;
-
-  acquire(&kmem.lock);
-  r = kmem.freelist;
+  int c;
+  push_off();
+  c = cpuid();
+  pop_off();
+  
+  acquire(&kmems[c].lock);
+  r = kmems[c].freelist;
   if(r)
-    kmem.freelist = r->next;
-  release(&kmem.lock);
+    kmems[c].freelist = r->next;
+  release(&kmems[c].lock);
+  // 如果本cpu物理页满了，可以尝试偷取其他cpu的物理页
+  if(!r && (r = steal(c))) {
+    acquire(&kmems[c].lock);
+    kmems[c].freelist = r->next;
+    release(&kmems[c].lock);
+  }
 
   if(r)
     memset((char*)r, 5, PGSIZE); // fill with junk
diff --git a/kernel/param.h b/kernel/param.h
index b5fdcb2..5a1b2b5 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -9,5 +9,6 @@
 #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-#define FSSIZE       1000  // size of file system in blocks
+#define FSSIZE       10000  // size of file system in blocks
 #define MAXPATH      128   // maximum file path name
+#define NBUCKET      13
