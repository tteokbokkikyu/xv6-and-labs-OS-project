diff --git a/Makefile b/Makefile
index c926b7e..483318d 100644
--- a/Makefile
+++ b/Makefile
@@ -193,7 +193,11 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
-
+	$U/_sleep\
+	$U/_pingpong\
+	$U/_primes\
+	$U/_find\
+	$U/_xargs\
 
 
 
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..bf0d87a
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+4
\ No newline at end of file
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..4851eba
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,38 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+void find(char* path, char* filename) {
+	char buf[512], * p;
+	int fd;
+	struct dirent de;
+	struct stat st;
+	strcpy(buf, path);
+	p = buf + strlen(buf);
+	*p++ = '/';
+	fd=open(path,0);
+    while (read(fd, &de, sizeof(de)) == sizeof(de)) {
+        if (de.inum == 0)
+            continue;
+        memmove(p, de.name, DIRSIZ);
+        p[DIRSIZ] = 0;
+        if (stat(buf, &st) < 0) {
+            printf("ls: cannot stat %s\n", buf);
+            continue;
+        }
+        if (st.type == T_DIR && strcmp(p, ".") != 0 && strcmp(p, "..") != 0) {
+            find(buf, filename);
+        }
+        else if (strcmp(filename, p) == 0)
+            printf("%s\n", buf);
+    }
+}
+int main(int argc, char* argv[]) {
+    if (argc != 3) {
+        printf("error\n usage:find <path><filename>\n ");
+        exit(1);
+    }
+    find(argv[1], argv[2]);
+    exit(0);
+}
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..0ebc2b0
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,55 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int main()
+{
+    int p1[2], p2[2];
+    char buf[4];
+    
+    // 创建两个管道
+    pipe(p1); // p1 用于子进程 -> 父进程
+    pipe(p2); // p2 用于父进程 -> 子进程
+    
+/*p1[0] 和 p2[0] 是管道的读取端（读端）。
+p1[1] 和 p2[1] 是管道的写入端（写端）。*/
+
+    int pid = fork();
+
+    if(pid > 0) {
+        // 父进程代码
+        close(p1[1]); // 关闭p1管道的写端
+        close(p2[0]); // 关闭p2管道的读端
+
+        // 向子进程发送“ping”
+        write(p2[1], "ping", 4);
+
+        // 从子进程接收“pong”
+        read(p1[0], buf, 4);
+        printf("%d: received %s\n", getpid(), buf);
+
+        // 关闭剩余的管道端
+        close(p1[0]);
+        close(p2[1]);
+    } else if(pid == 0) {
+        // 子进程代码
+        close(p1[0]); // 关闭p1管道的读端
+        close(p2[1]); // 关闭p2管道的写端
+
+        // 从父进程接收“ping”
+        read(p2[0], buf, 4);
+        printf("%d: received %s\n", getpid(), buf);
+
+        // 向父进程发送“pong”
+        write(p1[1], "pong", 4);
+
+        // 关闭剩余的管道端
+        close(p1[1]);
+        close(p2[0]);
+    } else {
+        // fork 失败
+        printf("fork error\n");
+        exit(1);
+    }
+
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/primes.c b/user/primes.c
new file mode 100644
index 0000000..f7c0d88
--- /dev/null
+++ b/user/primes.c
@@ -0,0 +1,44 @@
+#include "kernel/types.h"
+#include "user/user.h"
+ 
+void transmit(int lp[2], int rp[2], int p1) {
+	int data;
+	while (read(lp[0], &data, sizeof(int)) == sizeof(int))
+		if (data % p1)
+			write(rp[1], &data, sizeof(int));
+	close(lp[0]);
+	close(rp[1]);
+}
+
+void primes(int lp[2]) {
+	close(lp[1]);
+	int p1;
+	if(read(lp[0],&p1,sizeof(int))!=sizeof(int))//如果未能成功读取
+		exit(0);
+	printf("prime %d\n", p1);
+	int rp[2];
+	pipe(rp);
+	transmit(lp, rp, p1);
+	if (fork() == 0)
+		primes(rp);
+	else {
+		close(rp[0]);//关闭读端
+		wait(0);
+	}
+	exit(0);
+}
+
+int main(int argc, char const* argv[]) {
+	int p[2];
+	pipe(p);
+	for (int i = 2; i <36; i++)
+		write(p[1], &i, sizeof(int));
+	if (fork() == 0)//子进程
+		primes(p);
+	else {//父进程
+		close(p[1]);
+		close(p[0]);
+		wait(0);
+	}
+	exit(0);
+}
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..e4f38d2
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,11 @@
+#include "kernel/types.h"
+#include "user/user.h"
+int main(int argc, char *argv[])
+{
+	if(argc<2){
+		fprintf(2, "need a parameter for sleep\n");
+		exit(1);
+	}
+	sleep(atoi(argv[1])); 
+	exit(0);
+}
\ No newline at end of file
diff --git a/user/xargs.c b/user/xargs.c
new file mode 100644
index 0000000..a33d323
--- /dev/null
+++ b/user/xargs.c
@@ -0,0 +1,44 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/param.h"
+ 
+int main(int argc, char *argv[])
+{
+ if (argc < 2) {
+        fprintf(2, "Usage: xargs command ...\n");
+        exit(1);
+    }
+    char *new_argv[MAXARG];
+    int cur_argv = 0;
+    for (int i = 0; i < argc-1; i++,cur_argv++) {
+        new_argv[cur_argv] = argv[i+1];
+    }
+        char ch;
+        char buf[512];
+        char *cur_buf = buf;
+        new_argv[cur_argv++] = buf;
+        while(read(0, &ch, sizeof(char))){
+                if(ch == ' '||ch=='\t'){
+                        *cur_buf ='\0';
+                        cur_buf++;
+                        new_argv[cur_argv++] = cur_buf;
+                }else if(ch == '\n'){
+                        *cur_buf = '\0';
+                        new_argv[cur_argv] = 0;
+                        int pid = fork();
+                        if(pid == 0){
+                                exec(new_argv[0], new_argv);
+                                exit(0);
+                        }else{
+                                wait((int*)0);
+                                cur_buf = buf;
+                                cur_argv = argc;
+                        }
+                }else{
+                        *cur_buf = ch;
+                        cur_buf++;
+                }
+        }
+        exit(0);
+}
