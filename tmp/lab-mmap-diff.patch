diff --git a/Makefile b/Makefile
index 7a7e380..ac698dc 100644
--- a/Makefile
+++ b/Makefile
@@ -188,6 +188,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_mmaptest\
 
 
 
diff --git a/grade-lab-mmap b/grade-lab-mmap
index cd16700..d425d86 100755
--- a/grade-lab-mmap
+++ b/grade-lab-mmap
@@ -45,9 +45,7 @@ def test_mmaptest_fork_test():
 
 @test(19, "usertests")
 def test_usertests():
-    r.run_qemu(shell_script([
-        'usertests'
-    ]), timeout=420)
+    r.run_qemu(shell_script([    'usertests']), timeout=420)
     r.match('^ALL TESTS PASSED$')
 
 @test(1, "time")
diff --git a/kernel/proc.c b/kernel/proc.c
index 22e7ce4..891c131 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -5,6 +5,10 @@
 #include "spinlock.h"
 #include "proc.h"
 #include "defs.h"
+#include "fcntl.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "file.h"
 
 struct cpu cpus[NCPU];
 
@@ -141,6 +145,10 @@ found:
   p->context.ra = (uint64)forkret;
   p->context.sp = p->kstack + PGSIZE;
 
+  for(int i=0;i<VMASIZE;i++){
+    p->vmas[i].used=0;//初始化vmas
+  }
+
   return p;
 }
 
@@ -300,6 +308,16 @@ fork(void)
     if(p->ofile[i])
       np->ofile[i] = filedup(p->ofile[i]);
   np->cwd = idup(p->cwd);
+//lab10 复制父进程的 vmas 到子进程
+
+  for (int i = 0; i < VMASIZE; i++) {
+    np->vmas[i].used = 0;
+    if (p->vmas[i].used) { // 复制vma entry
+      memmove(&np->vmas[i], &p->vmas[i], sizeof(struct vm_area));
+      filedup(p->vmas[i].fd); // 增加引用次数
+    }
+  }
+
 
   safestrcpy(np->name, p->name, sizeof(p->name));
 
@@ -312,6 +330,10 @@ fork(void)
   release(&wait_lock);
 
   acquire(&np->lock);
+
+
+
+
   np->state = RUNNABLE;
   release(&np->lock);
 
@@ -344,6 +366,8 @@ exit(int status)
   if(p == initproc)
     panic("init exiting");
 
+
+
   // Close all open files.
   for(int fd = 0; fd < NOFILE; fd++){
     if(p->ofile[fd]){
@@ -352,7 +376,17 @@ exit(int status)
       p->ofile[fd] = 0;
     }
   }
-
+ for (int i = 0; i < VMASIZE; i++) {
+    if (p->vmas[i].used) {
+      if (p->vmas[i].flags & MAP_SHARED) {
+        filewrite(p->vmas[i].fd, p->vmas[i].addr, p->vmas[i].length);
+      }
+      fileclose(p->vmas[i].fd);
+      uvmunmap(p->pagetable, p->vmas[i].addr, p->vmas[i].length / PGSIZE, 1);
+      p->vmas[i].used = 0;
+    }
+ }//lab10 解除映射
+ 
   begin_op();
   iput(p->cwd);
   end_op();
diff --git a/kernel/proc.h b/kernel/proc.h
index f6ca8b7..b226d11 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -81,6 +81,18 @@ struct trapframe {
 };
 
 enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+#define VMASIZE 16
+//每个进程使用VMA数组记录映射的内存，大小为16
+
+struct vm_area{
+uint64 addr;//地址
+int length;//长度
+int prot;//指示内存是否应映射为可读、可写，以及/或者可执行
+int flags;//MAP_SHARED（映射内存的修改应写回文件）or MAP_PRIVATE（映射内存的修改不应写回文件）
+int offset;//假设为0
+struct file *fd;//映射的文件
+int used;//是否被使用
+};
 
 // Per-process state
 struct proc {
@@ -105,4 +117,9 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+  struct vm_area vmas[VMASIZE];//VMA数组
 };
+
+
+
diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..e423a43 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -104,6 +104,9 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
+extern uint64 sys_mmap(void);
+extern uint64 sys_munmap(void);
+
 
 static uint64 (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -127,6 +130,8 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_mmap]   sys_mmap,
+[SYS_munmap]   sys_munmap,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..f522c17 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_mmap   22
+#define SYS_munmap 23
\ No newline at end of file
diff --git a/kernel/sysfile.c b/kernel/sysfile.c
index 5dc453b..1ca2043 100644
--- a/kernel/sysfile.c
+++ b/kernel/sysfile.c
@@ -15,6 +15,10 @@
 #include "sleeplock.h"
 #include "file.h"
 #include "fcntl.h"
+#include "memlayout.h"
+// 定义max和min宏定义
+#define max(a, b) ((a) > (b) ? (a) : (b))
+#define min(a, b) ((a) < (b) ? (a) : (b))
 
 // Fetch the nth word-sized system call argument as a file descriptor
 // and return both the descriptor and the corresponding struct file.
@@ -484,3 +488,136 @@ sys_pipe(void)
   }
   return 0;
 }
+
+
+// lab10
+uint64 sys_mmap(void) {
+    uint64 addr;       // 地址
+    int length;        // 长度
+    int prot;          // 指示内存是否应映射为可读、可写，以及/或者可执行
+    int flags;         // MAP_SHARED（映射内存的修改应写回文件）or MAP_PRIVATE（映射内存的修改不应写回文件）
+    int offset;        // 偏移量
+    int fd;            // 文件描述符
+    struct file *f;    // 映射的文件
+
+    // 从用户空间获取参数
+    if (argaddr(0, &addr) < 0 || argint(1, &length) < 0 || argint(2, &prot) < 0 || 
+        argint(3, &flags) < 0 || argfd(4, &fd, &f) < 0 || argint(5, &offset) < 0) {
+        return -1;
+    }
+
+    // 参数检查
+    if (flags != MAP_SHARED && flags != MAP_PRIVATE) {
+        return -1;
+    }
+    if (length <= 0 || offset < 0) {
+        return -1;
+    }
+    
+    if (f->writable == 0 && (prot & PROT_WRITE) && flags == MAP_SHARED) {
+        return -1;
+    }
+
+    struct proc* p = myproc();
+
+    // 遍历 VMA 查找空闲位置
+    for (int i = 0; i < VMASIZE; i++) {
+        if (p->vmas[i].used == 0) {
+            p->vmas[i].used = 1;
+            p->vmas[i].addr = p->sz;
+            p->vmas[i].length = length;
+            p->vmas[i].flags = flags;
+            p->vmas[i].prot = prot;
+            p->vmas[i].fd = f;
+            p->vmas[i].offset = offset;
+            filedup(f); // 增加文件的引用
+            p->sz += length;
+            return p->vmas[i].addr;
+        }
+    }
+
+    return -1; // 没有找到空闲位置
+}
+
+
+
+
+uint64 sys_munmap(void) {
+    uint64 addr;
+    int length;
+    if (argaddr(0, &addr) < 0 || argint(1, &length) < 0)
+        return -1;
+
+    addr = PGROUNDDOWN(addr);
+    length = PGROUNDUP(length);
+
+    if (addr<=0||length <= 0) {
+        return -1;
+    }
+
+    struct proc *p = myproc();
+    struct vm_area *vma = 0;
+    int i = 0;
+
+    // 查找包含 addr 的 VMA
+    for (; i < VMASIZE; i++) {
+        if (p->vmas[i].used && addr >= p->vmas[i].addr && addr < p->vmas[i].addr + p->vmas[i].length) {
+            vma = &p->vmas[i];
+            break;
+        }
+    }
+
+    if (!vma||i==VMASIZE)
+        return -1;
+
+    // 写回文件
+    if (vma->flags == MAP_SHARED && (vma->prot & PROT_WRITE) != 0) {
+        filewrite(vma->fd, addr, length);
+    }
+
+    // 解除映射
+    uvmunmap(p->pagetable, addr, (length + PGSIZE - 1) / PGSIZE, 1);
+
+    // 更新 VMA
+    if (addr == vma->addr && length == vma->length) {
+        // 删除 VMA
+        vma->used = 0;
+        fileclose(vma->fd);
+        vma->fd = 0;
+    } else if (addr == vma->addr) {
+        // 更新 VMA 起始地址
+        vma->addr += length;
+        vma->offset += length;
+        vma->length -= length;
+    } else if (addr + length == vma->addr + vma->length) {
+        // 更新 VMA 结束地址
+        vma->length -= length;
+    } else if (addr > vma->addr && addr + length < vma->addr + vma->length) {
+        // 处理中间部分的 VMA
+        struct vm_area new_vma;
+        
+        // 创建新的 VMA 表示解除映射后的部分
+        new_vma.used = 1;
+        new_vma.addr = addr + length;
+        new_vma.length = (vma->addr + vma->length) - (addr + length);
+        new_vma.flags = vma->flags;
+        new_vma.prot = vma->prot;
+        new_vma.fd = vma->fd;
+        new_vma.offset = vma->offset + (addr + length - vma->addr);
+        
+        // 更新原有 VMA
+        vma->length = addr - vma->addr;
+        
+        // 在 VMA 数组中找到一个位置，插入新的 VMA
+        for (int j = 0; j < VMASIZE; j++) {
+            if (p->vmas[j].used == 0) {
+                p->vmas[j] = new_vma;
+                break;
+            }
+        }
+    } 
+
+    return 0;
+}
+
+
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..290fc05 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -5,6 +5,10 @@
 #include "spinlock.h"
 #include "proc.h"
 #include "defs.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "file.h"
+#include "fcntl.h"
 
 struct spinlock tickslock;
 uint ticks;
@@ -65,9 +69,78 @@ usertrap(void)
     intr_on();
 
     syscall();
-  } else if((which_dev = devintr()) != 0){
+  } 
+  else if(r_scause() == 12 || r_scause() == 13 || r_scause() == 15){
+    uint64 va = r_stval();  // 获取引起页错误的虚拟地址
+    struct proc *p = myproc();
+    struct vm_area *vma = 0;  // 初始化为 NULL
+    int i = 0;
+    if (va >= MAXVA) {
+        // 地址超出最大虚拟地址范围
+        p->killed = 1;
+        return;
+    }
+
+    // 查找包含 va 的 VMA
+    for (; i < VMASIZE; i++) {
+        if (p->vmas[i].used && va >= p->vmas[i].addr && va < p->vmas[i].addr + p->vmas[i].length) {
+            vma = &p->vmas[i];
+            break;
+        }
+    }
+
+    // 如果没有找到合适的 VMA，杀死进程
+    if (vma == 0||i==VMASIZE) {
+        p->killed = 1;
+        return;
+    }
+
+    va = PGROUNDDOWN(va);  // 对齐到页边界
+    uint64 pa = (uint64)kalloc();  // 分配一个新的物理页面
+    if (pa == 0) {
+        p->killed = 1;  // 分配失败，杀死进程
+        return;
+    }
+    memset((void*)pa, 0, PGSIZE);  // 清零分配的物理页面
+
+    uint64 file_offset = vma->offset + PGROUNDDOWN(va - vma->addr);
+    ilock(vma->fd->ip);  // 锁住 inode
+    if (readi(vma->fd->ip, 0, pa, file_offset, PGSIZE) < 0) {
+        iunlock(vma->fd->ip);
+        kfree((void*)pa);
+        p->killed = 1;
+        return;
+    }
+    iunlock(vma->fd->ip);
+
+    int prot_v = PTE_U;  // 用户权限
+    if (vma->prot & PROT_READ)
+        prot_v |= PTE_R;
+    if (vma->prot & PROT_WRITE)
+        prot_v |= PTE_W;
+    if (vma->prot & PROT_EXEC)
+        prot_v |= PTE_X;
+
+    // 建立虚拟地址到物理地址的映射关系
+    if (mappages(p->pagetable, va, PGSIZE, pa, prot_v) != 0) {
+        kfree((void*)pa);
+        p->killed = 1;
+    }
+}
+  
+  
+  
+  
+  
+  
+  
+  else if((which_dev = devintr()) != 0){
     // ok
-  } else {
+  }
+ 
+
+
+ else {
     printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
     printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
     p->killed = 1;
@@ -148,7 +221,6 @@ kerneltrap()
     printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
     panic("kerneltrap");
   }
-
   // give up the CPU if this is a timer interrupt.
   if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
     yield();
diff --git a/kernel/vm.c b/kernel/vm.c
index d5a12a0..3d1f575 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -175,9 +175,11 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
     if((pte = walk(pagetable, a, 0)) == 0)
       panic("uvmunmap: walk");
     if((*pte & PTE_V) == 0)
-      panic("uvmunmap: not mapped");
+       continue;
+      //panic("uvmunmap: not mapped");
     if(PTE_FLAGS(*pte) == PTE_V)
-      panic("uvmunmap: not a leaf");
+      continue;
+      //panic("uvmunmap: not a leaf");
     if(do_free){
       uint64 pa = PTE2PA(*pte);
       kfree((void*)pa);
@@ -309,7 +311,8 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
     if((pte = walk(old, i, 0)) == 0)
       panic("uvmcopy: pte should exist");
     if((*pte & PTE_V) == 0)
-      panic("uvmcopy: page not present");
+      continue;
+      //panic("uvmcopy: page not present");
     pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..301160a
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+8
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index b71ecda..e371f9b 100644
--- a/user/user.h
+++ b/user/user.h
@@ -23,6 +23,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+void *mmap(void *addr, int length, int prot, int flags, int fd, int offset);
+int munmap(void *add, int length);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..f6e8b06 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,5 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("mmap");
+entry("munmap");
\ No newline at end of file
